import * as core from '@actions/core'
import * as github from '@actions/github'
import {GitHub} from '@actions/github/lib/utils'

/* eslint-disable @typescript-eslint/no-explicit-any */

interface PullRequest {
  [key: string]: any
  number: number
}

interface IssueComment {
  [key: string]: any
  id: number
  body: string
}

interface CheckRun {
  [key: string]: any
  output: {
    [key: string]: any
    title: string
  }
  html_url: string
}

/* eslint-enable @typescript-eslint/no-explicit-any */

export class Runner {
  private octokit: InstanceType<typeof GitHub>
  private check_suite_id: number
  private head_branch: string
  private head_commit: string
  private workflow: string
  private owner: string
  private repo: string
  private signature: string
  private separator: string
  private tag: string

  constructor(api_token: string) {
    this.octokit = github.getOctokit(api_token)

    const payload = github.context.payload

    if (!payload.repository) {
      throw new Error("payload doesn't include `repository` key")
    }

    this.check_suite_id = payload.workflow_run.check_suite_id
    this.head_branch = payload.workflow_run.head_branch
    this.head_commit = payload.workflow_run.head_commit.id
    this.workflow = payload.workflow.name
    this.owner = payload.repository.owner.login
    this.repo = payload.repository.name

    this.signature = `GitHub Action status on ${this.head_commit} generated by failed-comment-action`
    this.separator = '\n<!-- SEPARATOR -->\n'
    this.tag = `<!-- WORKFLOW:${this.workflow} -->\n`
  }

  async run(): Promise<void> {
    if (!this.is_pull_request()) {
      core.info('Invoked without pull request')
      return
    }

    const prs = await this.find_pull_requests()
    if (prs.length === 0) {
      core.info(`No open pull requests found with ${this.head_branch} branch`)
      return
    }

    const failed_runs = await this.find_failed_check_runs()
    const section = this.generate_section(failed_runs)

    for (const pr of prs) {
      const comment = await this.find_comment(pr)
      if (comment) {
        await this.update_comment(comment, section)
        core.info('Updated comment')
      } else {
        await this.create_comment(pr, section)
        core.info('Created comment')
      }
    }
  }

  is_pull_request(): boolean {
    return (
      this.head_branch !== undefined &&
      this.head_branch !== null &&
      this.head_branch !== ''
    )
  }

  generate_section(failed_runs: CheckRun[]): string {
    const strings: string[] = []

    strings.push(this.tag)
    strings.push(`### ${this.workflow}\n`)

    if (failed_runs.length === 0) {
      strings.push('No jobs failed :+1:')
    } else {
      strings.push('| job | url |\n')
      strings.push('|-----|-----|\n')

      for (const failed_run of failed_runs) {
        const job = failed_run.output.title
        const url = failed_run.html_url
        strings.push(`| ${job} | ${url} |\n`)
      }
    }

    return strings.join()
  }

  async find_pull_requests(): Promise<PullRequest[]> {
    return (await this.octokit.paginate(this.octokit.pulls.list, {
      owner: this.owner,
      repo: this.repo,
      state: 'open',
      head: `${this.owner}:${this.head_branch}`
    })) as PullRequest[]
  }

  async find_failed_check_runs(): Promise<CheckRun[]> {
    const respnose = await this.octokit.paginate(
      this.octokit.checks.listForSuite,
      {
        owner: this.owner,
        repo: this.repo,
        check_suite_id: this.check_suite_id,
        status: 'completed'
      }
    )
    return respnose.check_runs.filter(check_run => {
      return check_run.conclusion === 'failure'
    }) as CheckRun[]
  }

  async find_comment(pr: PullRequest): Promise<IssueComment | null> {
    const comments = await this.octokit.paginate(
      this.octokit.issues.listComments,
      {
        owner: this.owner,
        repo: this.repo,
        issue_number: pr.number
      }
    )
    return comments.find(
      c => c.body !== undefined && c.body.includes(this.signature)
    ) as IssueComment | null
  }

  async update_comment(comment: IssueComment, section: string): Promise<void> {
    const old_sections = this.split_body(comment.body)
    const new_sections = this.replace_or_append_section(section, old_sections)
    const body = this.generate_body(new_sections)

    await this.octokit.issues.updateComment({
      owner: this.owner,
      repo: this.repo,
      comment_id: comment.id,
      body
    })
  }

  async create_comment(pr: PullRequest, section: string): Promise<void> {
    const body = this.generate_body([section])

    await this.octokit.issues.createComment({
      owner: this.owner,
      repo: this.repo,
      issue_number: pr.number,
      body
    })
  }

  split_body(body: string): string[] {
    return body
      .split(this.separator)
      .filter((section: string) => !section.includes(this.signature))
  }

  replace_or_append_section(section: string, old_sections: string[]): string[] {
    let replaced = false

    const new_sections = old_sections.map((old_section: string) => {
      if (old_section.includes(this.tag)) {
        replaced = true
        return section
      } else {
        return old_section
      }
    })

    if (!replaced) {
      new_sections.push(section)
    }

    return new_sections
  }

  generate_body(sections: string[]): string {
    return [this.signature].concat(sections).join(this.separator)
  }
}
